"use strict";var l=Object.create;var n=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,h=Object.prototype.hasOwnProperty;var f=(i,e)=>{for(var t in e)n(i,t,{get:e[t],enumerable:!0})},a=(i,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of w(e))!h.call(i,r)&&r!==t&&n(i,r,{get:()=>e[r],enumerable:!(o=m(e,r))||o.enumerable});return i};var C=(i,e,t)=>(t=i!=null?l(v(i)):{},a(e||!i||!i.__esModule?n(t,"default",{value:i,enumerable:!0}):t,i)),E=i=>a(n({},"__esModule",{value:!0}),i);var I={};f(I,{Chain:()=>u,newCrawler:()=>S});module.exports=E(I);var c=require("./services/IotexService"),s=C(require("events"));const x="s3://casimir-etl-event-bucket-dev/";var u=(t=>(t.Iotex="iotex",t.Accumulate="accumulate",t))(u||{});class g extends s.default{constructor(){super();this.init=new Date}main(){}}class p{constructor(e){this.config=e,this.init=new Date,this.service=null,this.isRunning=!1,this.EE=new g}async _initializeService(){if(this.config.chain==="iotex"){const e=await(0,c.newIotexService)();this.service=e;return}throw new Error("Unknown chain")}async start(){return null}}async function S(i={chain:"iotex"}){const e=new p({chain:"iotex",outputLocation:i.outputLocation??x});return await e._initializeService(),e}0&&(module.exports={Chain,newCrawler});
